/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. SampleData.jj */
/*@egen*/options{  JDK_VERSION = "1.5";  UNICODE_INPUT = true;  JAVA_UNICODE_ESCAPE = false;                                        STATIC = false;                   DEBUG_PARSER = false;  DEBUG_TOKEN_MANAGER = false;                                  }PARSER_BEGIN(SampleDataParser)package org.dbdoclet.xsd.sage;import java.io.ByteArrayInputStream;import java.io.UnsupportedEncodingException;public class SampleDataParser/*@bgen(jjtree)*/implements SampleDataParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTSampleDataParserState jjtree = new JJTSampleDataParserState();

/*@egen*/  private static final String ENCODING = "UTF-8";  public static NodeRoot parse(String buffer) throws UnsupportedEncodingException, ParseException  {    if (buffer == null)    {      return null;    }    ByteArrayInputStream instream = new ByteArrayInputStream(buffer.getBytes(ENCODING));    SampleDataParser parser = new SampleDataParser(instream, ENCODING);    NodeRoot root = parser.parse();    return root;  }}PARSER_END(SampleDataParser)SKIP :{  " "| "\t"| "\r"| "\n"}TOKEN :{  < DATA : "DATA" > : VALUES| < OPTIONS : "OPTIONS" >| < UNIQUE : "unique" >| < FOLLOWS : "follows" >| < WORD : ([ "a"-"z", "A"-"Z", "." ])+ >}< VALUES >TOKEN :{  < VALUE :    (      ("\n")+    )?    (~[ "\n" ])+    (      ("\n")+    )? >}NodeRoot parse()       :{/*@bgen(jjtree) Root */
  NodeRoot jjtn000 = new NodeRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Root */
  try {
/*@egen*/  < OPTIONS >  (    (      optionName() "=" optionValue()    )+  )?  < DATA >  (    value()  )+  < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void optionName()             :{/*@bgen(jjtree) OptionName */
  NodeOptionName jjtn000 = new NodeOptionName(JJTOPTIONNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) OptionName */
  try {
/*@egen*/  (    t = < UNIQUE >  | t = < FOLLOWS >  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.setToken(t);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void optionValue()              :{/*@bgen(jjtree) OptionValue */
  NodeOptionValue jjtn000 = new NodeOptionValue(JJTOPTIONVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) OptionValue */
  try {
/*@egen*/  t = < WORD >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.setToken(t);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void value()        :{/*@bgen(jjtree) Value */
  NodeValue jjtn000 = new NodeValue(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) Value */
  try {
/*@egen*/  t = < VALUE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.setToken(t);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}